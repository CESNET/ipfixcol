/**
 * \file template_table.h
 * \author Petr Kramolis <kramolis@cesnet.cz>
 * \brief 
 *
 * Copyright (C) 2011 CESNET, z.s.p.o.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of the Company nor the names of its contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * ALTERNATIVELY, provided that this notice is retained in full, this
 * product may be distributed under the terms of the GNU General Public
 * License (GPL) version 2 or later, in which case the provisions
 * of the GPL apply INSTEAD OF those given above.
 *
 * This software is provided ``as is, and any express or implied
 * warranties, including, but not limited to, the implied warranties of
 * merchantability and fitness for a particular purpose are disclaimed.
 * In no event shall the company or contributors be liable for any
 * direct, indirect, incidental, special, exemplary, or consequential
 * damages (including, but not limited to, procurement of substitute
 * goods or services; loss of use, data, or profits; or business
 * interruption) however caused and on any theory of liability, whether
 * in contract, strict liability, or tort (including negligence or
 * otherwise) arising in any way out of the use of this software, even
 * if advised of the possibility of such damage.
 *
 */

#ifndef _TEMPLATE_TABLE_H_
#define _TEMPLATE_TABLE_H_


#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <fastbit/ibis.h>
#include <map>
#include <vector>
#include <iostream>
#include <string>
#include "pugixml.hpp"
#include "fastbit_element.h"
#include <sys/stat.h>

extern "C" {
	#include <ipfixcol/storage.h>
	#include <semaphore.h>
}

/* this enum specifies types of file naming strategy */
enum name_type{TIME,INCREMENTAL};

uint64_t get_rows_from_part(const char *);
class element; //needed because of Circular dependency

/* For each uniq template is created instance of template_table object.
 * The object is used to parse data records belonging to the template
 * */
class template_table 
{
private:
	uint32_t _buff_size; //number of values 
	uint64_t _rows_in_window;
	uint64_t _rows_count;
	uint16_t _template_id;
	uint32_t _min_record_size;
	//ibis::tablex * _tablex;
	char _name[10];
	char _index;
public:
	/* vector of elements stored in data record (based on template)
	 * element polymorphs to necessary data type
 	 */
	std::vector<element *> elements;
	std::vector<element *>::iterator el_it;

	template_table(int template_id, uint32_t buff_size): _rows_count(0)
	{
		_template_id = template_id;
		sprintf(_name,"%u",template_id);
		//_tablex = ibis::tablex::create();
		_index=0;
		_rows_in_window = 0;
		_min_record_size = 0;
		if(buff_size == 0){
			 buff_size = RESERVED_SPACE;
		}
		_buff_size = buff_size;
	}
	int rows() {return _rows_count;}
	void rows(int rows_count) {_rows_count = rows_count;}
	std::string name(){return std::string(_name);}
	int parse_template(struct ipfix_template * tmp,struct fastbit_config *config);

	/**
	 * \brief parse data_set and store it's data in memory
	 *
	 * if memory usage is about to exceed memory limit
	 * data are flushed to disk.
	 *
	 * @param data_set ipfixcol data set
	 * @param path path to direcotry where should be data flushed
	 */
	int store(ipfix_data_set * data_set, std::string path);

	int update_part(std::string path){
		FILE *f;
		std::stringstream ss;
		std::string part;
		uint64_t rows_in_part;
		rows_in_part = get_rows_from_part((path + "/-part.txt").c_str());

		f = fopen((path + "/-part.txt").c_str(),"w");
		if(f == NULL){
			fprintf(stderr,"Error while updating part file");
			return 1;
		}
		//insert header
		ss << "BEGIN HEADER";
		ss << "\nName = " << std::string(this->_name);
		ss << "\nDescription = Generated by ipfixcol fastbit plugin";
		ss << "\nNumber_of_rows = " << _rows_in_window + rows_in_part;
		ss << "\nNumber_of_columns = " << elements.size();
		ss << "\nTimestamp = " << time(NULL);
		ss << "\nEND HEADER\n\n";
		//insert rows info
		for (el_it = elements.begin(); el_it!=elements.end(); ++el_it){
			ss << (*el_it)->get_part_info();
		}
		part = ss.str();
		fputs(part.c_str(),f);
		fclose(f);
		std::cout << "UPDATED PART from: " << rows_in_part << "to" << _rows_in_window + rows_in_part <<std::endl;
		return 0;
	}

	int dir_check(std::string path){
		size_t pos;
		//std::cout << "PATTH CHECK: \"" << path << "\"\n"; 	
		if(mkdir(path.c_str(), 0777) != 0){
			if(errno == EEXIST) //dir already exists 
				return 0;
			if(errno == ENOENT){ //check parent direcotry
				pos = path.find_last_of("/\\");
				if(pos == std::string::npos){
					std::cout << "Error while creating dir:\"" << path << "\"\n";
					return 1;
				}
				this->dir_check(path.substr(0,pos));
				//try create dir againe
				if(mkdir(path.c_str(),0777) != 0){
					std::cout << "Error while creating dir:\"" << path << "\"\n";
					return 1;
				}
				return 0;
			}
			//other error
			std::cout << "Error while creating dir:\"" << path << "\"\n";
			return 1;
		}
		return 0;
	}

	void reset_rows(){
		_rows_in_window = 0;
	}

	/**
	 * \brief flush data to disk and clean memory
	 *
	 * @param path path to direcotry where should be data flushed
	 */
	void flush(std::string path){
		//check directory!
		_rows_in_window += _rows_count;
		this->dir_check(path + _name);
		//flush data
		for (el_it = elements.begin(); el_it!=elements.end(); ++el_it) {
			(*el_it)->flush(path + _name);
		}
		//create/update -part.txt file
		this->update_part(path + _name);
		//_tablex->write((path + _name).c_str(),_name, "Generated by ipfixcol fastbit plugin", &_index);
		//_tablex->clearData();
		_rows_count = 0;
		_rows_in_window = 0;
	}
	~template_table();
};

struct fastbit_config{
	std::map<uint32_t,std::map<uint16_t,template_table*>* > *ob_dom;
	std::map<uint32_t,std::map<uint16_t,enum store_type> > *elements_types;
	std::map<uint16_t,template_table*> *templates; /* map with template id / template_table pairs */
	std::vector<std::string> *index_en_id; /* vector of elements which should be indexed.. stored in pairs first enterprise id second element id */
	std::vector<std::string> *dirs; /* directories for index & reorder thread */
	int time_window;  /* specifies time interval for storage directory rotation (0 = no time based rotation ) */
	int records_window;             /* specifies record count for storage directory rotation (0 = no record based rotation ) */
	enum name_type dump_name;       /* hold type of name strategy for storage directory rotation */
	std::string sys_dir;            /* path to directory where should be storage directory flushed */
	std::string window_dir;         /* current window directory */
	std::string prefix;             /* user prefix for storage directory */
	time_t last_flush;/* time of last flush (used for time based rotation, name is based on start of interval not its end!) */
	int reorder;	  /* specifies if stored data should be reordered */
	int indexes;      /* specifies if indexes should be build during storage. 0 = no indexes, 1 = index all, 2 = index only marked elements*/
	int buff_size;    /* size of buffer (number of values)*/
	sem_t sem;		  /* semaphore for index building thread */
};

#endif
